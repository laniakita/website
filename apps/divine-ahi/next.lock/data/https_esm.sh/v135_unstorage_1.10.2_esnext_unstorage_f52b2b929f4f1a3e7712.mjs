/* esm.sh - esbuild bundle(unstorage@1.10.2) esnext production */
import { Buffer as __Buffer$ } from "/v135/buffer@6.0.3/esnext/buffer.bundle.mjs";
import K from"/v135/destr@2.0.3/esnext/destr.mjs";function L(n){return!n||typeof n.then!="function"?Promise.resolve(n):n}function c(n,...t){try{return L(n(...t))}catch(u){return Promise.reject(u)}}function $(n){let t=typeof n;return n===null||t!=="object"&&t!=="function"}function C(n){let t=Object.getPrototypeOf(n);return!t||t.isPrototypeOf(Object)}function p(n){if($(n))return String(n);if(C(n)||Array.isArray(n))return JSON.stringify(n);if(typeof n.toJSON=="function")return p(n.toJSON());throw new Error("[unstorage] Cannot stringify value!")}function R(){if(typeof __Buffer$===void 0)throw new TypeError("[unstorage] Buffer is not supported!")}var P="base64:";function S(n){if(typeof n=="string")return n;R();let t=__Buffer$.from(n).toString("base64");return P+t}function j(n){return typeof n!="string"||!n.startsWith(P)?n:(R(),__Buffer$.from(n.slice(P.length),"base64"))}var E=["hasItem","getItem","getItemRaw","setItem","setItemRaw","removeItem","getMeta","setMeta","removeMeta","getKeys","clear","mount","unmount"];function A(n,t){if(t=v(t),!t)return n;let u={...n};for(let m of E)u[m]=(l="",...h)=>n[m](t+l,...h);return u.getKeys=(m="",...l)=>n.getKeys(t+m,...l).then(h=>h.map(w=>w.slice(t.length))),u}function f(n){return n?n.split("?")[0].replace(/[/\\]/g,":").replace(/:+/g,":").replace(/^:|:$/g,""):""}function O(...n){return f(n.join(":"))}function v(n){return n=f(n),n?n+":":""}function _(n){return n}var D="memory",T=()=>{let n=new Map;return{name:D,options:{},hasItem(t){return n.has(t)},getItem(t){return n.get(t)??null},getItemRaw(t){return n.get(t)??null},setItem(t,u){n.set(t,u)},setItemRaw(t,u){n.set(t,u)},removeItem(t){n.delete(t)},getKeys(){return Array.from(n.keys())},clear(){n.clear()},dispose(){n.clear()}}};function F(n={}){let t={mounts:{"":n.driver||T()},mountpoints:[""],watching:!1,watchListeners:[],unwatch:{}},u=e=>{for(let r of t.mountpoints)if(e.startsWith(r))return{base:r,relativeKey:e.slice(r.length),driver:t.mounts[r]};return{base:"",relativeKey:e,driver:t.mounts[""]}},m=(e,r)=>t.mountpoints.filter(s=>s.startsWith(e)||r&&e.startsWith(s)).map(s=>({relativeBase:e.length>s.length?e.slice(s.length):void 0,mountpoint:s,driver:t.mounts[s]})),l=(e,r)=>{if(t.watching){r=f(r);for(let s of t.watchListeners)s(e,r)}},h=async()=>{if(!t.watching){t.watching=!0;for(let e in t.mounts)t.unwatch[e]=await W(t.mounts[e],l,e)}},w=async()=>{if(t.watching){for(let e in t.unwatch)await t.unwatch[e]();t.unwatch={},t.watching=!1}},z=(e,r,s)=>{let i=new Map,a=o=>{let g=i.get(o.base);return g||(g={driver:o.driver,base:o.base,items:[]},i.set(o.base,g)),g};for(let o of e){let g=typeof o=="string",I=f(g?o:o.key),d=g?void 0:o.value,M=g||!o.options?r:{...r,...o.options},B=u(I);a(B).items.push({key:I,value:d,relativeKey:B.relativeKey,options:M})}return Promise.all([...i.values()].map(o=>s(o))).then(o=>o.flat())},y={hasItem(e,r={}){e=f(e);let{relativeKey:s,driver:i}=u(e);return c(i.hasItem,s,r)},getItem(e,r={}){e=f(e);let{relativeKey:s,driver:i}=u(e);return c(i.getItem,s,r).then(a=>K(a))},getItems(e,r){return z(e,r,s=>s.driver.getItems?c(s.driver.getItems,s.items.map(i=>({key:i.relativeKey,options:i.options})),r).then(i=>i.map(a=>({key:O(s.base,a.key),value:K(a.value)}))):Promise.all(s.items.map(i=>c(s.driver.getItem,i.relativeKey,i.options).then(a=>({key:i.key,value:K(a)})))))},getItemRaw(e,r={}){e=f(e);let{relativeKey:s,driver:i}=u(e);return i.getItemRaw?c(i.getItemRaw,s,r):c(i.getItem,s,r).then(a=>j(a))},async setItem(e,r,s={}){if(r===void 0)return y.removeItem(e);e=f(e);let{relativeKey:i,driver:a}=u(e);a.setItem&&(await c(a.setItem,i,p(r),s),a.watch||l("update",e))},async setItems(e,r){await z(e,r,async s=>{if(s.driver.setItems)return c(s.driver.setItems,s.items.map(i=>({key:i.relativeKey,value:p(i.value),options:i.options})),r);s.driver.setItem&&await Promise.all(s.items.map(i=>c(s.driver.setItem,i.relativeKey,p(i.value),i.options)))})},async setItemRaw(e,r,s={}){if(r===void 0)return y.removeItem(e,s);e=f(e);let{relativeKey:i,driver:a}=u(e);if(a.setItemRaw)await c(a.setItemRaw,i,r,s);else if(a.setItem)await c(a.setItem,i,S(r),s);else return;a.watch||l("update",e)},async removeItem(e,r={}){typeof r=="boolean"&&(r={removeMeta:r}),e=f(e);let{relativeKey:s,driver:i}=u(e);i.removeItem&&(await c(i.removeItem,s,r),(r.removeMeta||r.removeMata)&&await c(i.removeItem,s+"$",r),i.watch||l("remove",e))},async getMeta(e,r={}){typeof r=="boolean"&&(r={nativeOnly:r}),e=f(e);let{relativeKey:s,driver:i}=u(e),a=Object.create(null);if(i.getMeta&&Object.assign(a,await c(i.getMeta,s,r)),!r.nativeOnly){let o=await c(i.getItem,s+"$",r).then(g=>K(g));o&&typeof o=="object"&&(typeof o.atime=="string"&&(o.atime=new Date(o.atime)),typeof o.mtime=="string"&&(o.mtime=new Date(o.mtime)),Object.assign(a,o))}return a},setMeta(e,r,s={}){return this.setItem(e+"$",r,s)},removeMeta(e,r={}){return this.removeItem(e+"$",r)},async getKeys(e,r={}){e=v(e);let s=m(e,!0),i=[],a=[];for(let o of s){let I=(await c(o.driver.getKeys,o.relativeBase,r)).map(d=>o.mountpoint+f(d)).filter(d=>!i.some(M=>d.startsWith(M)));a.push(...I),i=[o.mountpoint,...i.filter(d=>!d.startsWith(o.mountpoint))]}return e?a.filter(o=>o.startsWith(e)&&!o.endsWith("$")):a.filter(o=>!o.endsWith("$"))},async clear(e,r={}){e=v(e),await Promise.all(m(e,!1).map(async s=>{if(s.driver.clear)return c(s.driver.clear,s.relativeBase,r);if(s.driver.removeItem){let i=await s.driver.getKeys(s.relativeBase||"",r);return Promise.all(i.map(a=>s.driver.removeItem(a,r)))}}))},async dispose(){await Promise.all(Object.values(t.mounts).map(e=>x(e)))},async watch(e){return await h(),t.watchListeners.push(e),async()=>{t.watchListeners=t.watchListeners.filter(r=>r!==e),t.watchListeners.length===0&&await w()}},async unwatch(){t.watchListeners=[],await w()},mount(e,r){if(e=v(e),e&&t.mounts[e])throw new Error(`already mounted at ${e}`);return e&&(t.mountpoints.push(e),t.mountpoints.sort((s,i)=>i.length-s.length)),t.mounts[e]=r,t.watching&&Promise.resolve(W(r,l,e)).then(s=>{t.unwatch[e]=s}).catch(console.error),y},async unmount(e,r=!0){e=v(e),!(!e||!t.mounts[e])&&(t.watching&&e in t.unwatch&&(t.unwatch[e](),delete t.unwatch[e]),r&&await x(t.mounts[e]),t.mountpoints=t.mountpoints.filter(s=>s!==e),delete t.mounts[e])},getMount(e=""){e=f(e)+":";let r=u(e);return{driver:r.driver,base:r.base}},getMounts(e="",r={}){return e=f(e),m(e,r.parents).map(i=>({driver:i.driver,base:i.mountpoint}))}};return y}async function H(n,t){t=v(t);let u=await n.getKeys(t),m={};return await Promise.all(u.map(async l=>{m[l.slice(t.length)]=await n.getItem(l)})),m}async function X(n,t,u=""){u=v(u),await Promise.all(Object.entries(t).map(m=>n.setItem(u+m[0],m[1])))}function W(n,t,u){return n.watch?n.watch((m,l)=>t(m,u+l)):()=>{}}async function x(n){typeof n.dispose=="function"&&await c(n.dispose)}var q={azureAppConfiguration:"unstorage/drivers/azure-app-configuration",azureCosmos:"unstorage/drivers/azure-cosmos",azureKeyVault:"unstorage/drivers/azure-key-vault",azureStorageBlob:"unstorage/drivers/azure-storage-blob",azureStorageTable:"unstorage/drivers/azure-storage-table",cloudflareKVBinding:"unstorage/drivers/cloudflare-kv-binding",cloudflareKVHTTP:"unstorage/drivers/cloudflare-kv-http",cloudflareR2Binding:"unstorage/drivers/cloudflare-r2-binding",fs:"unstorage/drivers/fs",fsLite:"unstorage/drivers/fs-lite",github:"unstorage/drivers/github",http:"unstorage/drivers/http",indexedb:"unstorage/drivers/indexedb",localStorage:"unstorage/drivers/localstorage",lruCache:"unstorage/drivers/lru-cache",memory:"unstorage/drivers/memory",mongodb:"unstorage/drivers/mongodb",netlifyBlobs:"unstorage/drivers/netlify-blobs",overlay:"unstorage/drivers/overlay",planetscale:"unstorage/drivers/planetscale",redis:"unstorage/drivers/redis",sessionStorage:"unstorage/drivers/session-storage",vercelKV:"unstorage/drivers/vercel-kv","cloudflare-kv-binding":"unstorage/drivers/cloudflare-kv-binding","cloudflare-kv-http":"unstorage/drivers/cloudflare-kv-http"};export{q as builtinDrivers,F as createStorage,_ as defineDriver,O as joinKeys,v as normalizeBaseKey,f as normalizeKey,A as prefixStorage,X as restoreSnapshot,H as snapshot};
//# sourceMappingURL=unstorage.mjs.map