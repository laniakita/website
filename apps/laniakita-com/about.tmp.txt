 
   Regardless, both self-hosted options like the above and the various CMSaaSes operate in a pretty standardized manner. You design a schema, which gets translated into either a RESTful API endpoint to FETCH/PUT/POST/PATCH (or a GraphQL endpoint), so you can pipe data into and out of the cms directly into/from your front-end. Certain CMSes may do extra things like authentication, similar to the various BaaSes, but by and large the schema builder to API model is a shared similarity.


 While the back-end capabilities of a Full-Stack framework often means you're really just building the [Back-End for the Front-End](https://samnewman.io/patterns/architectural/bff/), meaning that in some cases you really should not use a full-stack framework to replace a dedicated back-end application framework, hence the biggest reason I use them for is to creating a secure separation between dataflows. Though it's nice a framework provides routing and templating out of the box, but splitting data between client and server is something create-react-app simply cannot do (as far as I'm aware). 


 I'm fairly certain that last point is partially why headless CMSes and BaaS and GraphQL became such a huge thing for a hot-minute and why you might've heard the term JAMStack in the pre-pandemic era, since you could escape the security short comings of a pure front-end, with a dedicated back-end application that handles all the sensitive bits for you (on top of being hosted on a dedicated server). OH! But you did need a middleware to sit between the frontend and the backend to do that. IIRC, I used to use Apollo GraphQL with GraphCMS that integrated an Apollo client with a Gatsby front-end.
  
   I should point out that Next and SvelteKit aren't the end all be all though by any means. I found Remix to be a pretty cool Next.js alternative that uses Vite (the same bundler SvelteKit uses) instead of Webpack. For sites that aren't quite so JS heavy, and can make good use of the "interactive islands" architecture, Astro (a framework I see as a modern full-stack version of Gatsby) is something I've experimented with, and Deno's Fresh (preact based) is next on my todo list (11ty is another framework and looks like a great alternative for even lighter sites, plus you can write Lit! how cool is that).



One, I like knowing how my tools work on a low level. Two, vim motions + my own keybinds + autocommands is quite a nice productivity boost. Three, the Nixvim team has done an incredible job converting Neovim + it's massive third-party plugin ecosystem into configurable nix modules, as well as repackaging/converting all those binaries into nix compatible packages. If you happen to use Nix, maybe consider giving Nixvim a try? ^-^

In the past I've used MacOS and also Windows with WSL, but I primarily use a dedicated Linux Workstation nowadays, especially because my tools work the best with it.
   
   My primary purpose for using NixOS is it's unique ability that lets you declarativly define multiple machine configuration files in a single flake. The added benefit that you can rollback to previous update (without any stale data!) is quite nice too. The latter is possible due to how nix version controls programs with its own /nix/store, and also the fact that it doesn't use a traditional file system.

   which you can also version control in a git repo. These files can define everything, programs, containers, running services, even dotfiles, with it's own functional programming language, Nix.

   To take things a step further, with the help of a simple cron job to run a daily ```git pull && nixos-rebuild switch```, I can push an update to the config repo, and every declared machine will automagically get and apply that update all by themselves, no SSH needed (unless something goes wrong of course)! It's like Ansible/Puppet on steroids.
  
