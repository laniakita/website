---
title: Bot Clicker
date: 2024-05-06T21:41:14Z
descr: Bot Clicker is a tiny satirical game where you click on robots.
---
## TLDR

To briefly summarize Bot Clickers internals, it uses a combination of Three.js + Three.js component libraries and zustand from the Poimandres developer collective. Zustand is used to both add and store the total clicker points, as well as send that data to the overlayed clicker counter. The counter total is also an input parameter in function that calculates game/bot movement speed for added "eXtReMe EnTeRtAiNmEnT vAlUe!". 

The actual robot models were provided by Oscar Creativo, and the sounds were provided by FilmCow (voices) and Atelier Magicae (musical sounds). For more details on those amazing Artists, please visit the [credits](/credits) page.

## Introduction

I kinda created Bot Clicker by accident. Originally, I was just trying to make something visually interesting for my landing page. But, one thing led to another, and I wound up expanding on the [Flying Bananas example](https://codesandbox.io/s/2ycs3) from the react three fiber docs to create this toy "game" that's also somewhat a nod to the iconic [Cow Clicker](https://en.wikipedia.org/wiki/Cow_Clicker), created by Ian Bogost.

While I haven't gone as far as making players earn the "clicks" to click on the bots, I also don't feel like that's the point I'm trying to make with Bot Clicker. As such, it's up to the player to figure it out for themselves üßê.

As far as technicals go, once I had actually stumbled onto the ideas that led to Bot Clicker, I felt there were two hard requirements I had to keep in mind. 
  1. Bot clicker needed to load quickly (no long loading screens). 
  2. Bot Clicker needed somewhat high fidelity graphics (i.e. post-processing shaders) with a decent framerate to boot. 
Admitedly the second goal wasn't that challenging to achieve since many optimization implementations (instancing, LOD, etc.) come OOTB from Three.js. Regardless, WebGL isn't quite as performant as WebGPU, so there were still some compromises that had to be made to get things running as well as they do. While I'd like to have experimented with Three's WebGPU support, the actual WebGPU API is only at [57.29%](https://web3dsurvey.com/webgpu) platform support as of May 6th, 2024. So, WebGL was my only real option.

Beyond that, everything else was relatively straight forward. Especially since I could recycle some of the logic for spawning/placing/moving/rotating/teleporting the robots from the [Flying Bananas example](https://codesandbox.io/s/2ycs3) I mentioned above. Which also helped to point me in the right direction for some of the optimization steps I decided to implement. Once I had things moving and in place, the last part was to just build the rest of "Bot Clicker". I essentially just made a few minor tweaks to the example which includes but was not limited to:
  1. Using robots instead of bananas
  2. Using Next.js instead of a SPA React app
  3. Adding a  few optimizations of my own. For example there's only 30 bots on mobile devices, while there's 60 bots on desktop. Also, LOD is used/implemented a bit differently.
  4. Adding some functions to load & randomize the sounds when a bot is clicked. 
  5. Adding functions that scale the robot up on a successful click (and scale back down after a 2 second period).
  6. Implementing zustand to keep track of the clicks (I deliberatly chose to only count clicks of scaled bots to discourage click spamming the same bot).
  7. Adding functions that make movement speed dependent on the total number of clicks.
  8. Adding stars and the logic that make them move.
  9. Using a bloom post-processing shader instead of the depth of field shader.
  10. Implementing React Three A11y to prevent the bots from moving for those who have reduced motion on.
  11. Adding a menu with buttons that showcase a warning before you play/enter bot clicker. Also features the actual button that "soft" navigates you to the url that enables you to play bot clicker.
  12. Writing logic for a bright hemisphere light when out of the game, and logic that adds a postional light and removes/greatly decreases the hemisphere light in the game.
  13. Writing logic that keeps bot movement very limited on the actual landing page, but brings them to life when the game is actually entered.
  14. Writing logic that ensures the stars, post-processing, and bot animations only get loaded when the game is actually enterered.
  15. Adding a very dark and blurry "safety" div to cover the bots when out of the game.
  16. Writing logic that ensures bots only "react" to clicks when engaged in the game (clicks actually fall right through the blurry div despite my best efforts, so this was what I came up with).
I'm sure there's more but that's most of the steps I took to make the rest of the Bot Clicker.

## Loading Fast

To accomplish the first goal (since Bot Clicker is a web game, after all), it was necessary to compress the robot model from megabytes to mere kilobytes. This was accomplished using gltfjsx, a handy cli tool for running both draco compressions and doing the tedious work of mapping out the transformed model into typed react-three/fiber components.

Because the model is rigged and animated (makes instancing challenging), my best option was implementing a Level of Detail (LOD) which was thankfully provided by Three. This meant compressing the model's textures into three different resolutions: 512x, 256x, and 128x, for respective distances of close, medium, and far. Using the tool above, I was able to compress the 7.7 MiB glTF model into a 393.9 KiB .glb, 228.5 KiB .glb, and a 181.1 KiB .glb.

As I didn't want to make things too data intensive on slower mobile connections, only the latter two textures display on mobile screen sizes. This means 256x model is used for close distances and the 128x model for any distance beyond that. This has the added side effect of increasing framerates, which I'll get to in the next section. 

## Optimizations

Since it was important to make use of post-processing shaders (specificallly pmndrs' bloom, which is an implementation of [L√©na Piquet's custom bloom for UEv4](https://www.froyok.fr/blog/2021-12-ue4-custom-bloom)), whilst maintaining a decent framerate with WebGL, it was critical to optimize things as best I could. The most significant of those optimizations was making use of Three's LOD implementation (which react-three/drei conveniently provides a light wrapper for as the "Detailed" component) with heavily reduced texture resolutions. The rest of the optimizations were mostly tweaks to the canvas setting (turning off anti-aliasing, flat tone mapping, etc.)

### Level of Detail (LOD)

Before settling on LOD, I did initially want to instance the model (why waste 80 draw calls on 80 identical meshes?), however, Three (to my knowledge) doesn't yet support animation clips on instanced meshes. So, while I'm sure some creative workarounds exist to make such a thing possible, I felt just using Three's LOD implementation was a good compromise.

Like I mentioned in the previous section, Three's LOD implementation takes at least two models to setup the rendering that switches between them depending on their distance from the camera. So, I chose to compress the model's textures three separate times in 512x, 256x, and 128x resolutions to feed the LOD implementation. While I could've added a 1024x resolution to be the closest to the camera, in testing I found it both increased load times (iirc the .glb was about 1.8 MiBs) and weaker devices just chugged frames trying to render it, so I decided against.

I also created two seperate LOD components that reactively render based on the size of a players screen. Non-mobile screen sizes get the LOD component with all three resolutions, and mobile screens get the LOD component with only last two resolutions.

My reasoning for separating the LOD into separate components is two fold. Firstly, for faster load times on slow data connections (which i mentioned previously). Secondly, to accomodate the limitations of mobile phone processors, especially the ones onboard devices with ultra high resolution displays. I found doing things this way, rather than using a single LOD to rule them all, seemed to provide better performance (i.e. higher-framerates) on mobile devices, so the separate LODs made it into the final game.

## Rest of the Bot Clicker (ROTFBC)

Everything else beyond that was relatively straight forward. A simple function inside react-three/fibers useFrame hook spreads out the bots to their positions, moves them upwards, and also spins them around. Another function triggers once a bot goes beyond the top of a players screen and teleports them a little below the bottom edge of the players screen (yes, there's not actually infinite robots, I hope you can make peace with this fact). a function in the useFrame hook rotates the stars (which come from the drei library) around so it felt like you were spinning with the robots too in outer space.

The actual audio is loaded on demand with Three's AudioLoader. As well, since there's two sets of sounds (one enum stores locations of the noises from FilmCow, the other enum stores the locations of noises from Atelier Magicae) I wrote a function so there's a 50% chance of getting a sound from either library, and then various probabilities of the specific sound you hear from the randomly selected library.

You'll also notice the large epilepsy warning for Bot Clicker, which I'm not 100% sure warrants it, but I felt it was best to err on the side of caution anyway. This is because once the bots move fast enough the reflection from the spotlight in the up-close bot might appear as a flicker, which is probably not good for someone with photosensitive epilepsy. This was partially the reason why I disabled the bot animations (bottom spinner thing with lights might look like a flicker) and bright post-processing bloom effect (they make the bot eyes flicker a bit) and the stars too (they twinkle), and significantly slowed down the bot movement speed when you aren't actively engaged in the game. For extra caution I also added a darkened-blurry div on top the canvas. Which I realized also looked sorta cool.

Disabling such extra stuff really helps with out-of-game performance too! As I really don't want to crash anyone's browser for simply visiting my website if the game happens to be too heavy for their device. I'm also not sure the game will even load if your devices browser isn't compatible with the JS version used by Three, so hopefully older devices won't have too much issue visiting the home page (aside from not being able to play Bot Clicker, which some might even view as a plus).

The other thing I did was make use of react-three/a11y to stop the bots from moving around if a user does happen to have "prefer reduced motion" enabled in their browser. This way, even if they don't actually play the game they'll remain static behind the blurred div I layered on top the canvas.

